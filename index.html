import React, { useEffect, useRef, useState } from "react";
import { Chart, LineController, LineElement, PointElement, LinearScale, TimeScale, Title, Tooltip, Legend, Filler } from 'chart.js';
import 'chartjs-adapter-moment';

Chart.register(LineController, LineElement, PointElement, LinearScale, TimeScale, Title, Tooltip, Legend, Filler);

export default function YouMoveApp(){
  // UI state
  const [listenerAdded, setListenerAdded] = useState(false);
  const [running, setRunning] = useState(false);
  const [zero, setZero] = useState(0);
  const [minVal, setMinVal] = useState(Infinity);
  const [maxVal, setMaxVal] = useState(-Infinity);
  const [currentAngle, setCurrentAngle] = useState(NaN);
  const [savedRecords, setSavedRecords] = useState([]);
  const [sensorStatus, setSensorStatus] = useState('idle');

  // controls
  const jointRef = useRef('Shoulder');
  const planeRef = useRef('beta');
  const sideRef = useRef('Right');

  // TTS & audio
  const [ttsMode, setTtsMode] = useState('chime'); // off | chime | speak
  const [voicePref, setVoicePref] = useState('en,de,es');
  const [voices, setVoices] = useState([]);
  const [selectedVoice, setSelectedVoice] = useState('');
  const volRef = useRef(0.9);

  // buffers
  const sessionBufferRef = useRef([]); // samples for current auto-save window
  const chartBufferRef = useRef([]);   // rolling buffer for chart

  // chart
  const chartRef = useRef(null);
  const chartInstanceRef = useRef(null);
  const LIVE_WINDOW_SEC = 30;
  const AUTO_SAVE_MS = 20000;
  const autoSaveTimerRef = useRef(null);

  // helper: toast (simple)
  const toastRef = useRef(null);
  function toast(msg, ms=1400){
    if(!toastRef.current) return;
    toastRef.current.textContent = msg;
    toastRef.current.style.opacity = '1';
    clearTimeout((toastRef.current)._t);
    (toastRef.current)._t = setTimeout(()=>{ if(toastRef.current) toastRef.current.style.opacity='0'; }, ms);
  }

  // load voices
  useEffect(()=>{
    if(!('speechSynthesis' in window)) return;
    function load(){
      const v = window.speechSynthesis.getVoices();
      setVoices(v || []);
    }
    load();
    window.speechSynthesis.onvoiceschanged = load;
    return ()=>{ window.speechSynthesis.onvoiceschanged = null; };
  },[]);

  // chart init
  useEffect(()=>{
    const ctx = chartRef.current.getContext('2d');
    chartInstanceRef.current = new Chart(ctx, {
      type: 'line',
      data: { datasets: [
        { label: 'Angle (°)', data: [], borderColor:'#50c878', backgroundColor:'rgba(80,200,120,0.08)', pointRadius:0, tension:0.15 },
        { label: 'Mean', data: [], borderColor:'#ffc857', borderDash:[6,4], pointRadius:0, fill:false, tension:0 }
      ]},
      options: {
        animation:false,
        responsive:true,
        interaction:{mode:'index',intersect:false},
        scales:{
          x:{ type:'time', time:{ tooltipFormat:'YYYY-MM-DD HH:mm:ss', unit:'second', displayFormats:{second:'HH:mm:ss'} }, ticks:{autoSkip:true,maxTicksLimit:6} },
          y:{ beginAtZero:false }
        },
        plugins:{legend:{display:true}}
      }
    });
    return ()=>{ chartInstanceRef.current?.destroy(); };
  },[]);

  // utility: push chart point (rolling)
  function pushChartPoint(time, value){
    const buf = chartBufferRef.current;
    buf.push({x: time, y: value});
    const cutoff = new Date(Date.now() - 10*60*1000);
    while(buf.length && buf[0].x < cutoff) buf.shift();
  }

  function refreshChart(){
    const now = new Date();
    const windowStart = new Date(now.getTime() - LIVE_WINDOW_SEC*1000);
    const visible = chartBufferRef.current.filter(pt=>pt.x >= windowStart);
    const values = visible.map(pt=>pt.y);
    const meanVal = values.length ? values.reduce((a,b)=>a+b,0)/values.length : NaN;
    const inst = chartInstanceRef.current;
    if(!inst) return;
    inst.data.datasets[0].data = visible;
    inst.data.datasets[1].data = visible.map(pt=>({x:pt.x,y:meanVal}));
    inst.update('none');
  }

  // device orientation handler
  function deviceHandler(e){
    if(!running) return;
    const a = (typeof e.alpha==='number')?e.alpha:0;
    const b = (typeof e.beta==='number')?e.beta:0;
    const g = (typeof e.gamma==='number')?e.gamma:0;
    let raw = 0;
    const plane = planeRef.current;
    if(plane === 'alpha') raw = ((a + 540) % 360) - 180;
    else if(plane === 'beta') raw = b;
    else raw = g;
    const adjusted = raw - zero;
    const wrapped = ((adjusted + 180) % 360) - 180;
    setCurrentAngle(wrapped);
    if(wrapped > maxVal) setMaxVal(wrapped);
    if(wrapped < minVal) setMinVal(wrapped);
    const now = new Date();
    sessionBufferRef.current.push({time: now, value: wrapped});
    pushChartPoint(now, wrapped);
    refreshChart();
  }

  // attach sensor listener after permission
  function attachListener(){
    if(listenerAdded) return;
    window.addEventListener('deviceorientation', deviceHandler, {passive:true});
    setListenerAdded(true);
    setSensorStatus('ready');
    toast('Sensors ready — press Start Session');
  }

  // permission flow invoked by user click
  function handleEnableSensors(){
    if(!('DeviceOrientationEvent' in window)){
      setSensorStatus('not-supported'); toast('Device orientation not supported'); return;
    }
    if(typeof DeviceOrientationEvent.requestPermission === 'function'){
      DeviceOrientationEvent.requestPermission().then(p=>{
        if(p === 'granted') attachListener(); else { setSensorStatus('blocked'); toast('Permission denied'); }
      }).catch(err=>{ console.warn(err); setSensorStatus('blocked'); toast('Permission error'); });
    } else attachListener();
  }

  // audio: chime
  const audioCtxRef = useRef(null);
  useEffect(()=>{ if(window.AudioContext || window.webkitAudioContext) audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)(); },[]);
  function playChime(vol=0.9){
    const ctx = audioCtxRef.current; if(!ctx) return;
    const now = ctx.currentTime;
    const o = ctx.createOscillator(); const g = ctx.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(880, now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(Math.max(0.01, vol*0.15), now + 0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
    o.connect(g); g.connect(ctx.destination); o.start(now); o.stop(now + 0.27);
  }

  // TTS
  function loadVoices(){ if(!('speechSynthesis' in window)) return []; return window.speechSynthesis.getVoices() || []; }
  useEffect(()=>{ setVoices(loadVoices()); if('speechSynthesis' in window) window.speechSynthesis.onvoiceschanged = ()=> setVoices(loadVoices()); },[]);

  function pickVoice(order){
    const VO = voices || [];
    for(const pref of order){
      let v = VO.find(v=>v.lang && v.lang.toLowerCase().startsWith(pref+'-'));
      if(v) return v;
      v = VO.find(v=>v.lang && v.lang.toLowerCase().startsWith(pref));
      if(v) return v;
    }
    return VO.find(v=>v.lang && !v.lang.toLowerCase().startsWith('ar')) || VO[0] || null;
  }

  function speakText(text){
    if(!('speechSynthesis' in window) || !text) return;
    const mode = ttsMode;
    if(mode === 'chime'){ playChime(volRef.current); return; }
    if(mode === 'off') return;
    const order = (voicePref.split(',')||['en','de','es']).map(s=>s.trim());
    const voice = selectedVoice ? voices.find(v=>v.name===selectedVoice) : pickVoice(order);
    try{
      window.speechSynthesis.cancel();
      const ut = new SpeechSynthesisUtterance(text);
      ut.rate = 0.95; ut.pitch = 1.0; ut.volume = volRef.current;
      if(voice){ ut.voice = voice; ut.lang = voice.lang || order[0]; }
      else ut.lang = order[0];
      window.speechSynthesis.speak(ut);
    }catch(e){ console.warn('tts', e); }
  }

  // auto-save action
  function autoSaveAction(){
    const buf = sessionBufferRef.current;
    if(!buf.length) return;
    const mean = buf.reduce((s,a)=>s+a.value,0)/buf.length;
    const last = buf[buf.length-1];
    const ts = new Date();
    const rec = { timestamp_iso: ts.toISOString(), timestamp_local: ts.toLocaleString(), joint: jointRef.current, plane: planeRef.current, side: sideRef.current, angle: Number(last.value.toFixed(2)), mean: Number(mean.toFixed(2)) };
    setSavedRecords(prev=>[rec, ...prev]);
    // speak
    if(ttsMode === 'chime') playChime(volRef.current);
    else if(ttsMode === 'speak') speakText(`${rec.joint} ${rec.side}. angle ${rec.angle} degrees. mean ${rec.mean} degrees.`);
    toast('Auto-saved ' + rec.timestamp_local);
    sessionBufferRef.current = [];
  }

  // controls: start/stop
  function startSession(){ if(!listenerAdded){ toast('Enable sensors first'); return; } if(running) return; setRunning(true); setSensorStatus('running'); autoSaveTimerRef.current = setInterval(autoSaveAction, AUTO_SAVE_MS); toast('Session started'); }
  function stopSession(){ if(!running) return; setRunning(false); setSensorStatus('stopped'); clearInterval(autoSaveTimerRef.current); autoSaveAction(); toast('Session stopped (final save)'); }

  // enable handlers for UI refs
  useEffect(()=>{ jointRef.current = jointRef.current; planeRef.current = planeRef.current; sideRef.current = sideRef.current; },[]);

  // expose some debug for console
  useEffect(()=>{ window.YOUMOVE = { chartBufferRef, sessionBufferRef, savedRecords }; },[savedRecords]);

  // render
  return (
    <div className="p-4">
      <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:12}}>
        <h2>YouMOVE – Deine Gelenkbewegung: privat, offline und vollkommen cloudfrei</h2>
        <div style={{display:'flex',gap:8}}>
          <button className="btn primary" onClick={handleEnableSensors}>Enable Sensors</button>
          <button className="btn" onClick={()=>{ setZero(currentAngle || 0); toast('Zero set'); }}>Set Zero</button>
          <button className="btn" onClick={()=>{ setMinVal(Infinity); setMaxVal(-Infinity); toast('Min/Max reset'); }}>Reset Min/Max</button>
        </div>
      </div>

      <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:12}}>
        <div className="card">
          <label>Joint</label>
          <select defaultValue="Shoulder" onChange={e=>{ jointRef.current=e.target.value; }}>
            <option>Shoulder</option><option>Elbow</option><option>Wrist</option><option>Hip</option><option>Knee</option><option>Ankle</option><option>Rest</option>
          </select>
        </div>
        <div className="card">
          <label>Plane</label>
          <select defaultValue="beta" onChange={e=>{ planeRef.current=e.target.value; }}>
            <option value="beta">Flexion/Extension (β)</option>
            <option value="gamma">Abduction/Adduction (γ)</option>
            <option value="alpha">Rotation (α)</option>
          </select>
        </div>
      </div>

      <div style={{display:'grid',gridTemplateColumns:'repeat(6,1fr)',gap:8,marginTop:12}}>
        <div className="tile"><span>Angle (°)</span><h3>{Number.isFinite(currentAngle)?currentAngle.toFixed(1):'—'}</h3></div>
        <div className="tile"><span>Max (°)</span><h3>{isFinite(maxVal)?maxVal.toFixed(1):'—'}</h3></div>
        <div className="tile"><span>Min (°)</span><h3>{isFinite(minVal)?minVal.toFixed(1):'—'}</h3></div>
        <div className="tile"><span>Zero Ref (°)</span><h3>{Number.isFinite(zero)?zero.toFixed(1):'—'}</h3></div>
        <div className="tile"><span>Mean (°)</span><h3>{sessionBufferRef.current.length? (sessionBufferRef.current.reduce((s,a)=>s+a.value,0)/sessionBufferRef.current.length).toFixed(1):'—'}</h3></div>
        <div className="tile"><span>Mode</span><h3>{jointRef.current.includes('Rest')?'Rest':'Active'}</h3></div>
      </div>

      <div style={{display:'flex',gap:8,marginTop:12}}>
        <button className="btn primary" onClick={startSession}>Start Session</button>
        <button className="btn warn" onClick={stopSession}>Stop Session</button>
        <button className="btn" onClick={()=>{
          // export savedRecords
          if(!savedRecords.length){ toast('No saved records'); return; }
          const header = ['timestamp_iso','timestamp_local','joint','plane','side','angle_deg','mean_deg'];
          const rows = savedRecords.map(r=>[r.timestamp_iso, `"${r.timestamp_local.replace(/"/g,'""')}"`, r.joint, r.plane, r.side, r.angle, r.mean].join(','));
          const csv = [header.join(','), ...rows].join('\n');
          const blob = new Blob([`\uFEFF${csv}`], {type:'text/csv;charset=utf-8;'});
          const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download = `youmove_sessions_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.csv`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
          toast('Export ready');
        }}>Export CSV</button>
        <div style={{marginLeft:'auto',alignSelf:'center'}} className="pill">Sensors: {sensorStatus}</div>
      </div>

      <div style={{marginTop:12}} className="card"><canvas ref={chartRef} /></div>

      <div className="card" style={{marginTop:12}}>
        <strong>Saved Sessions</strong>
        <div style={{overflow:'auto',marginTop:8}}>
          <table style={{width:'100%'}}>
            <thead><tr><th>Timestamp</th><th>Joint</th><th>Plane</th><th>Side</th><th>Angle</th><th>Mean</th></tr></thead>
            <tbody>
              {savedRecords.map((r, i)=>(<tr key={i}><td>{r.timestamp_local}</td><td>{r.joint}</td><td>{r.plane}</td><td>{r.side}</td><td>{r.angle.toFixed(1)}</td><td>{r.mean.toFixed(1)}</td></tr>))}
            </tbody>
          </table>
        </div>
      </div>

      <div style={{marginTop:12}} className="card small-muted">
        <pre style={{whiteSpace:'pre-wrap',margin:0,fontFamily:'inherit',fontSize:13}}>
Disclaimer: This tool is intended for screening, exercise guidance, and documentation support. It does not replace clinical judgment or certified goniometry where required.

Intellectual Property: The software, design, code, and all algorithms are the intellectual property of Moustafa Mohammed Elsayed Ali and are protected by copyright and patent law. Any reproduction, distribution, or commercial use without explicit written permission is prohibited.

Contact: Moustafa Mohammed Elsayed Ali
Adresse: Kronwittener Straße 1, 84367 Tann, Germany
Telefon: +49 1522 5321568
E-Mail: mostischmidbauer@web.de | dptmostafa@gmail.com
LinkedIn: https://www.linkedin.com/in/moustafa-ali-024471aa/
        </pre>
      </div>

      <div ref={toastRef} style={{position:'fixed',left:'50%',transform:'translateX(-50%)',bottom:16,background:'#072027',padding:'8px 12px',borderRadius:10,color:'#dff6ea',opacity:0,transition:'opacity .2s'}} />
    </div>
  );
}
