<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>YouMOVE – Deine Gelenkbewegung: privat, offline und vollkommen cloudfrei</title>
<style>
:root{--bg:#0b1016;--card:#121820;--muted:#8aa0b2;--text:#eaf2f8;--accent:#50c878;--warn:#ffc857}
*{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0;padding:0}
body{background:linear-gradient(180deg,#0b1016,#0e141c);color:var(--text);-webkit-font-smoothing:antialiased;line-height:1.3}
.wrap{max-width:980px;margin:0 auto;padding:14px}
header{display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;gap:12px;margin:6px 0 14px}
h1{font-size:18px;margin:0}
.card{background:var(--card);border:1px solid #1d2732;border-radius:14px;padding:12px;margin:10px 0;box-shadow:0 6px 20px rgba(0,0,0,.28)}
label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
select, button{width:100%;padding:10px;border-radius:10px;border:1px solid #203040;background:#0b1118;color:var(--text);font-size:15px}
.row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px}
.btn{cursor:pointer}
.btn.primary{background:var(--accent);color:#072d19;border:0;font-weight:700}
.btn.warn{background:var(--warn);color:#432;border:0}
.kpi{display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));gap:8px;margin-bottom:8px}
.tile{background:#0a121a;border:1px solid #1d2a38;border-radius:10px;padding:10px;text-align:center}
.tile h3{margin:4px 0 0;font-size:18px}
.tile span{font-size:12px;color:var(--muted)}
canvas{width:100%!important;height:180px!important;display:block}
table{width:100%;border-collapse:collapse;color:var(--text);font-size:13px}
th,td{padding:6px;border:1px solid #16202a;text-align:center}
th{background:#0d1318;color:var(--muted)}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#0f1b23;padding:8px 12px;border-radius:8px;border:1px solid #1f2f3a;display:none;z-index:999}
@media(max-width:560px){.row{grid-template-columns:1fr}}
</style>

<!-- Chart.js + moment adapter -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0"></script>
</head>
<body>
<div class="wrap">
  <header>
    <h1>YouMOVE – Deine Gelenkbewegung: privat, offline und vollkommen cloudfrei</h1>
    <div style="display:flex;gap:8px;flex-wrap:wrap;max-width:420px;">
      <button id="btnEnable" class="btn primary" title="Enable sensors">Enable Sensors</button>
      <button id="btnCalibrate" class="btn" title="Set zero">Set Zero</button>
      <button id="btnResetMinMax" class="btn" title="Reset min/max">Reset Min/Max</button>
    </div>
  </header>

  <div class="card">
    <div class="row">
      <div>
        <label>Joint</label>
        <select id="joint">
          <option>Shoulder</option><option>Elbow</option><option>Wrist</option><option>Hip</option><option>Knee</option><option>Ankle</option><option>Rest</option>
        </select>
      </div>
      <div>
        <label>Plane / Movement</label>
        <select id="plane">
          <option value="beta">Flexion/Extension (β)</option>
          <option value="gamma">Abduction/Adduction (γ)</option>
          <option value="alpha">Rotation (α)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Side</label>
        <select id="side"><option>Right</option><option>Left</option><option>Midline</option></select>
      </div>
      <div>
        <label>Voice Language</label>
        <select id="ttsLang"><option value="en-US">English</option><option value="de-DE">Deutsch</option><option value="es-ES">Español</option></select>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="kpi">
      <div class="tile"><span>Angle (°)</span><h3 id="angle">0.0</h3></div>
      <div class="tile"><span>Max (°)</span><h3 id="max">0.0</h3></div>
      <div class="tile"><span>Min (°)</span><h3 id="min">0.0</h3></div>
      <div class="tile"><span>Zero (°)</span><h3 id="zero">0.0</h3></div>
      <div class="tile"><span>Mean (°)</span><h3 id="mean">0.0</h3></div>
      <div class="tile"><span>Joint / Rest</span><h3 id="jointRest">—</h3></div>
    </div>

    <div class="row" style="margin-top:6px;">
      <div>
        <button id="btnStart" class="btn primary">Start Session</button>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
        <button id="btnStop" class="btn warn">Stop Session</button>
        <button id="btnTestVoice" class="btn">Test Voice</button>
      </div>
    </div>

    <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;">
      <button id="btnExport" class="btn">Export CSV</button>
      <span class="tile" id="sensorStatus" style="padding:8px">Sensors: idle</span>
    </div>
  </div>

  <div class="card">
    <canvas id="liveChart"></canvas>
  </div>

  <div class="card">
    <table id="savedSessions">
      <thead>
        <tr><th>Timestamp</th><th>Joint</th><th>Plane</th><th>Side</th><th>Angle</th><th>Mean</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="card" style="font-size:12px;color:var(--muted)">
    <strong>Disclaimer:</strong> This tool is intended for screening, exercise guidance, and documentation support. It does not replace clinical judgment or certified goniometry where required.<br><br>
    <strong>IP:</strong> Software, code and algorithms © Moustafa Mohammed Elsayed Ali. Contact: <a href="mailto:mostischmidbauer@web.de">mostischmidbauer@web.de</a>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(function(){
  // UI refs
  const ui = {
    angle: document.getElementById('angle'),
    min: document.getElementById('min'),
    max: document.getElementById('max'),
    zero: document.getElementById('zero'),
    mean: document.getElementById('mean'),
    jointRest: document.getElementById('jointRest'),
    sensorStatus: document.getElementById('sensorStatus'),
    btnEnable: document.getElementById('btnEnable'),
    btnCalibrate: document.getElementById('btnCalibrate'),
    btnResetMinMax: document.getElementById('btnResetMinMax'),
    btnStart: document.getElementById('btnStart'),
    btnStop: document.getElementById('btnStop'),
    btnTestVoice: document.getElementById('btnTestVoice'),
    btnExport: document.getElementById('btnExport'),
    joint: document.getElementById('joint'),
    plane: document.getElementById('plane'),
    side: document.getElementById('side'),
    ttsLang: document.getElementById('ttsLang'),
    savedSessions: document.querySelector('#savedSessions tbody'),
    toast: document.getElementById('toast'),
    sensorStatusTile: document.getElementById('sensorStatus'),
    angleKPI: document.getElementById('angle'),
    maxKPI: document.getElementById('max'),
    minKPI: document.getElementById('min'),
    zeroKPI: document.getElementById('zero'),
    meanKPI: document.getElementById('mean'),
    jointRestKPI: document.getElementById('jointRest')
  };

  // State
  let running = false;
  let zero = 0;
  let minVal = Infinity;
  let maxVal = -Infinity;
  let currentAngle = 0;
  let listenerAdded = false;
  let sessionSamples = []; // buffer between autosaves
  let chartData = [];      // all live points for chart (Date + value)
  let allSessions = [];    // saved snapshots
  let autoSaveTimer = null;
  let ttsUtterance = null;
  const LIVE_WINDOW_SEC = 30;

  // Chart.js setup (time scale)
  const ctx = document.getElementById('liveChart').getContext('2d');
  const liveChart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [
        { label: 'Angle (°)', data: [], borderColor: '#50c878', backgroundColor: 'rgba(80,200,120,0.12)', tension: 0.2 },
        { label: 'Mean', data: [], borderColor: '#ffc857', borderDash: [5,5], fill: false, pointRadius: 0, tension: 0 }
      ]
    },
    options: {
      animation: false,
      responsive: true,
      parsing: false,
      normalized: true,
      scales: {
        x: { type: 'time', time: { tooltipFormat: 'YYYY-MM-DD HH:mm:ss', unit: 'second' } },
        y: { beginAtZero: true }
      },
      plugins: { legend: { display: true } }
    }
  });

  function showToast(msg, ms = 1200) {
    ui.toast.textContent = msg; ui.toast.style.display = 'block';
    setTimeout(()=> ui.toast.style.display = 'none', ms);
  }

  // Enable sensors (permissions)
  function enableSensors() {
    if(!window.DeviceOrientationEvent) {
      ui.sensorStatusTile.textContent = 'Sensors: not supported';
      showToast('Device orientation not supported');
      return;
    }
    // iOS
    if(typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission().then(p => {
        if(p === 'granted') startSensorListener();
        else { ui.sensorStatusTile.textContent = 'Sensors: blocked'; showToast('Permission denied'); }
      }).catch(()=> { ui.sensorStatusTile.textContent = 'Sensors: blocked'; showToast('Permission error'); });
    } else {
      startSensorListener();
    }
  }

  function startSensorListener() {
    if(listenerAdded) return;
    window.addEventListener('deviceorientation', onOrient, true);
    listenerAdded = true;
    ui.sensorStatusTile.textContent = 'Sensors: ready';
    showToast('Sensors enabled');
  }

  // Orientation handler (pushes points at event rate)
  function onOrient(e) {
    if(!running) return;
    const a = (typeof e.alpha === 'number') ? e.alpha : 0;
    const b = (typeof e.beta === 'number') ? e.beta : 0;
    const g = (typeof e.gamma === 'number') ? e.gamma : 0;

    // choose axis
    let raw;
    switch(ui.plane.value) {
      case 'alpha': raw = ((a + 540) % 360) - 180; break;
      case 'gamma': raw = g; break;
      default: raw = b; // beta
    }

    const angle = ((raw - zero + 180) % 360) - 180;
    if(isNaN(angle)) return;

    currentAngle = angle;
    if(angle > maxVal) maxVal = angle;
    if(angle < minVal) minVal = angle;

    const now = new Date();
    sessionSamples.push({ time: now, value: angle });
    chartData.push({ x: now, y: angle });

    updateKPIs();
    updateChart();
  }

  // Update KPIs: angle, min, max, zero, mean
  function updateKPIs() {
    ui.angleKPI.textContent = Number(currentAngle || 0).toFixed(1);
    ui.maxKPI.textContent = isFinite(maxVal) ? Number(maxVal).toFixed(1) : '0.0';
    ui.minKPI.textContent = isFinite(minVal) ? Number(minVal).toFixed(1) : '0.0';
    ui.zeroKPI.textContent = Number(zero || 0).toFixed(1);
    // Compute mean from live chartData (all points in current session)
    const recentPoints = chartData.slice(-1000); // safety cap
    const mean = recentPoints.length ? recentPoints.reduce((s,p)=>s+p.y,0)/recentPoints.length : 0;
    ui.meanKPI.textContent = isFinite(mean) ? Number(mean).toFixed(1) : '0.0';
    ui.jointRestKPI.textContent = ui.joint.value.includes('Rest') ? 'Rest' : 'Active';
  }

  // Update Chart: show last LIVE_WINDOW_SEC seconds
  function updateChart() {
    const now = new Date();
    const windowStart = new Date(now.getTime() - LIVE_WINDOW_SEC * 1000);
    const visible = chartData.filter(p => p.x >= windowStart);

    // update dataset[0] with {x,y} and dataset[1] with mean line
    liveChart.data.datasets[0].data = visible;
    const vals = visible.map(p => p.y);
    const mean = vals.length ? vals.reduce((a,b)=>a+b,0)/vals.length : 0;
    liveChart.data.datasets[1].data = vals.map((v,i) => ({ x: visible[i] ? visible[i].x : new Date(), y: mean }));
    liveChart.update('none');
  }

  // Save current buffer every 20s
  function autoSave() {
    if(!sessionSamples.length) return;
    const valid = sessionSamples.filter(s => Number.isFinite(s.value));
    if(!valid.length) { sessionSamples = []; return; }

    const mean = valid.reduce((a,b)=>a+b.value,0)/valid.length;
    const last = valid[valid.length - 1];

    const entry = {
      time: last.time,
      joint: ui.joint.value,
      plane: ui.plane.value,
      side: ui.side.value,
      angle: Number(last.value).toFixed(1),
      mean: Number(mean).toFixed(1)
    };

    allSessions.push(entry);
    renderTable();

    // TTS (only if user started the session — Start is user gesture)
    if(window.speechSynthesis && running) {
      try {
        if(ttsUtterance) window.speechSynthesis.cancel();
        const lang = ui.ttsLang.value || 'en-US';
        let text = '';
        if(lang === 'de-DE') text = `Winkel ${entry.angle} Grad`;
        else if(lang === 'es-ES') text = `Ángulo ${entry.angle} grados`;
        else text = `Angle ${entry.angle} degrees`;

        ttsUtterance = new SpeechSynthesisUtterance(text);
        ttsUtterance.lang = lang;
        ttsUtterance.volume = 0.45;
        ttsUtterance.rate = 0.95;
        window.speechSynthesis.speak(ttsUtterance);
      } catch (err) {
        console.warn('TTS error', err);
      }
    }

    // clear buffer (chartData remains for visualization)
    sessionSamples = [];
  }

  function renderTable() {
    ui.savedSessions.innerHTML = '';
    // newest first
    for(let i = allSessions.length - 1; i >= 0; i--) {
      const s = allSessions[i];
      const tr = document.createElement('tr');
      const ts = new Date(s.time).toLocaleString();
      tr.innerHTML = `<td>${ts}</td><td>${escapeHtml(s.joint)}</td><td>${escapeHtml(s.plane)}</td><td>${escapeHtml(s.side)}</td><td>${s.angle}</td><td>${s.mean}</td>`;
      ui.savedSessions.appendChild(tr);
    }
  }

  function escapeHtml(str) { return String(str).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  // UI buttons
  ui.btnEnable.addEventListener('click', enableSensors);

  ui.btnStart.addEventListener('click', () => {
    if(!listenerAdded) { showToast('Enable sensors first (tap Enable Sensors)'); return; }
    // Start does two important things: sets running and starts autosave timer.
    running = true;
    ui.sensorStatus.textContent = 'Session running';
    // Start autosave timer (20s) if not already
    if(!autoSaveTimer) autoSaveTimer = setInterval(autoSave, 20000);
    // also speak a small welcome—this is a user gesture so will allow TTS on mobile
    try {
      if(ttsUtterance) window.speechSynthesis.cancel();
      const lang = ui.ttsLang.value || 'en-US';
      let welcome = lang === 'de-DE' ? 'Aufnahme gestartet' : lang === 'es-ES' ? 'Grabación iniciada' : 'Session started';
      const u = new SpeechSynthesisUtterance(welcome);
      u.lang = lang; u.volume = 0.3; u.rate = 1.0;
      window.speechSynthesis.speak(u);
    } catch(e){}
    showToast('Session started');
  });

  ui.btnStop.addEventListener('click', () => {
    running = false;
    ui.sensorStatus.textContent = 'Session stopped';
    if(autoSaveTimer) { clearInterval(autoSaveTimer); autoSaveTimer = null; }
    if(ttsUtterance) window.speechSynthesis.cancel();
    showToast('Session stopped');
  });

  ui.btnTestVoice.addEventListener('click', () => {
    // explicit user gesture to test TTS
    if(!window.speechSynthesis) { showToast('TTS not supported'); return; }
    try {
      if(ttsUtterance) window.speechSynthesis.cancel();
      const lang = ui.ttsLang.value || 'en-US';
      const sample = lang === 'de-DE' ? 'Test. Stimme aktiviert.' : lang === 'es-ES' ? 'Prueba. voz activada.' : 'Test. Voice active.';
      const u = new SpeechSynthesisUtterance(sample);
      u.lang = lang; u.volume = 0.4; u.rate = 0.95;
      window.speechSynthesis.speak(u);
      showToast('TTS test spoken');
    } catch(e) { console.warn(e); showToast('TTS error'); }
  });

  ui.btnCalibrate.addEventListener('click', () => {
    zero = currentAngle || 0;
    showToast('Zero set');
    updateKPIs();
  });

  ui.btnResetMinMax.addEventListener('click', () => {
    minVal = Infinity; maxVal = -Infinity;
    updateKPIs();
    showToast('Min/Max reset');
  });

  ui.btnExport.addEventListener('click', () => {
    if(!allSessions.length) { showToast('No saved sessions'); return; }
    let csv = 'Timestamp,Joint,Plane,Side,Angle,Mean\n';
    allSessions.forEach(s => {
      csv += `"${new Date(s.time).toLocaleString()}",${escapeCsv(s.joint)},${escapeCsv(s.plane)},${escapeCsv(s.side)},${s.angle},${s.mean}\n`;
    });
    const blob = new Blob([ '\uFEFF' + csv ], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'youmove_sessions.csv'; a.click();
    URL.revokeObjectURL(url);
  });

  function escapeCsv(v){ return `"${String(v).replace(/"/g,'""')}"`; }

  // Clean up on page hide/unload
  window.addEventListener('beforeunload', () => {
    if(listenerAdded) window.removeEventListener('deviceorientation', onOrient, true);
    if(autoSaveTimer) clearInterval(autoSaveTimer);
  });

  // ensure chart updates even if no device events (use small interval)
  setInterval(() => {
    updateKPIs();
    updateChart();
  }, 600);

})();
</script>
</body>
</html>

