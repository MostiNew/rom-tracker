<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ROM Tracker – YouMOVE</title>

<!-- Styles (mobile-first, touch-friendly) -->
<style>
  :root{
    --bg:#0b1016; --card:#121820; --muted:#8aa0b2; --text:#eaf2f8;
    --accent:#50c878; --warn:#ffc857; --card-ink:#a9bfd2;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    background:linear-gradient(180deg,#0b1016,#0e141c); color:var(--text);
    -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;
  }
  .wrap{max-width:980px;margin:0 auto;padding:14px;display:flex;flex-direction:column;gap:12px}
  header{display:flex;flex-direction:column;gap:10px}
  header .top{display:flex;justify-content:space-between;align-items:center;gap:12px}
  h1{font-size:18px;margin:0}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{padding:12px;border-radius:12px;border:1px solid #203040;background:#0b1118;color:var(--text);font-size:15px;cursor:pointer}
  .btn{display:inline-flex;align-items:center;justify-content:center}
  .btn.primary{background:var(--accent);color:#072d19;border-color:#0d5b3a;font-weight:700}
  .btn.warn{background:var(--warn);color:#432;border-color:#a77}
  .card{background:var(--card);border:1px solid #1d2732;border-radius:14px;padding:12px;box-shadow:0 8px 32px rgba(0,0,0,.35)}
  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
  select,input{width:100%;padding:10px;border-radius:10px;border:1px solid #203040;background:#0b1118;color:var(--text);font-size:15px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .tile{background:#08101a;border:1px solid #16222c;border-radius:12px;padding:10px;text-align:center}
  .tile span{font-size:12px;color:var(--muted);display:block}
  .tile h3{margin:6px 0 0;font-size:18px}
  canvas{width:100%!important;height:180px!important;display:block;border-radius:8px}
  table{width:100%;border-collapse:collapse;color:var(--card-ink);font-size:13px}
  th,td{padding:8px;border-bottom:1px solid #16222c;text-align:left}
  th{font-weight:600;color:var(--accent);background:#081116}
  .hint{font-size:12px;color:var(--muted);margin-top:6px}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:#081216;border:1px solid #16222c;font-size:13px}
  /* responsive */
  @media(min-width:720px){
    header{flex-direction:row;align-items:center}
    .kpi{grid-template-columns:repeat(6,1fr)}
    .row{grid-template-columns:repeat(2,1fr)}
  }
</style>

<!-- Chart + adapter -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0"></script>
</head>
<body>
<div class="wrap">

  <header>
    <div class="top">
      <h1>YouMOVE — Live ROM Tracker (offline)</h1>
      <div class="controls">
        <button id="btnEnable" class="btn primary">Enable Sensors</button>
        <button id="btnCalibrate" class="btn">Set Zero</button>
        <button id="btnResetMinMax" class="btn">Reset Min/Max</button>
      </div>
    </div>
    <div class="hint">Open on a mobile device with motion sensors. On iOS, tap <strong>Enable Sensors</strong> and allow Motion & Orientation access.</div>
  </header>

  <!-- selections -->
  <div class="card">
    <div class="row">
      <div>
        <label for="joint">Joint</label>
        <select id="joint" aria-label="Joint">
          <option>Shoulder</option><option>Elbow</option><option>Wrist</option>
          <option>Hip</option><option>Knee</option><option>Ankle</option><option>Rest</option>
        </select>
      </div>
      <div>
        <label for="plane">Plane / Movement</label>
        <select id="plane" aria-label="Plane">
          <option value="beta">Flexion/Extension (β)</option>
          <option value="gamma">Abduction/Adduction (γ)</option>
          <option value="alpha">Rotation (α)</option>
        </select>
      </div>
    </div>
    <div style="margin-top:8px">
      <label for="side">Side</label>
      <select id="side" aria-label="Side">
        <option>Right</option><option>Left</option><option>Midline</option>
      </select>
    </div>
  </div>

  <!-- KPIs + controls -->
  <div class="card">
    <div class="kpi" aria-hidden="false">
      <div class="tile"><span>Angle (°)</span><h3 id="angle">—</h3></div>
      <div class="tile"><span>Max (°)</span><h3 id="max">—</h3></div>
      <div class="tile"><span>Min (°)</span><h3 id="min">—</h3></div>
      <div class="tile"><span>Zero Ref (°)</span><h3 id="zero">—</h3></div>
      <div class="tile"><span>Mean (°)</span><h3 id="mean">—</h3></div>
      <div class="tile"><span>Mode</span><h3 id="jointRest">—</h3></div>
    </div>

    <div style="display:flex;gap:8px;margin-top:10px;flex-wrap:wrap">
      <button id="btnStart" class="btn primary">Start Session</button>
      <button id="btnStop" class="btn warn">Stop Session</button>
      <button id="btnExport" class="btn">Export CSV</button>
      <div class="pill" id="sensorStatus">Sensors: idle</div>
    </div>
    <div class="hint">Sessions auto-save every 20 seconds and are spoken aloud.</div>
  </div>

  <!-- chart -->
  <div class="card">
    <strong>Live Session Chart (last 30s)</strong>
    <canvas id="liveChart" aria-label="Live angle chart"></canvas>
  </div>

  <!-- saved -->
  <div class="card">
    <strong>Saved Sessions</strong>
    <div style="overflow:auto;margin-top:8px;">
      <table id="savedSessionsTable" aria-label="Saved sessions table">
        <thead>
          <tr><th>Timestamp</th><th>Joint</th><th>Plane</th><th>Side</th><th>Angle</th><th>Mean</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- legal -->
  <div class="card">
    <p style="color:var(--muted);font-size:13px;margin:0;">
      <strong>Disclaimer:</strong> This tool is intended for screening, exercise guidance, and documentation support. It does not replace clinical judgment or certified goniometry.<br>
      <strong>Contact:</strong> <a href="mailto:mostischmidbauer@web.de">mostischmidbauer@web.de</a>
    </p>
  </div>

</div>

<!-- minimal toast -->
<div id="toast" style="position:fixed;left:50%;transform:translateX(-50%);bottom:16px;background:#072027;padding:8px 12px;border-radius:10px;color:#dff6ea;display:none;z-index:999"></div>

<!-- libs already loaded above -->
<script>
(() => {
  // UI refs
  const ui = {
    angle: document.getElementById('angle'),
    max: document.getElementById('max'),
    min: document.getElementById('min'),
    zero: document.getElementById('zero'),
    mean: document.getElementById('mean'),
    jointRest: document.getElementById('jointRest'),
    btnEnable: document.getElementById('btnEnable'),
    btnCalibrate: document.getElementById('btnCalibrate'),
    btnResetMinMax: document.getElementById('btnResetMinMax'),
    btnStart: document.getElementById('btnStart'),
    btnStop: document.getElementById('btnStop'),
    btnExport: document.getElementById('btnExport'),
    joint: document.getElementById('joint'),
    plane: document.getElementById('plane'),
    side: document.getElementById('side'),
    sensorStatus: document.getElementById('sensorStatus'),
    savedBody: document.querySelector('#savedSessionsTable tbody'),
    toast: document.getElementById('toast'),
    chartCanvas: document.getElementById('liveChart')
  };

  // state
  let running = false;
  let listenerAdded = false;
  let zero = 0;
  let minVal = Infinity, maxVal = -Infinity;
  let currentAngle = 0;
  const sessionSamples = [];   // samples used to compute mean for current auto-save window
  const chartData = [];        // master buffer for chart (kept rolling)
  const savedRecords = [];     // saved rows for export
  const LIVE_WINDOW_SEC = 30;
  const AUTO_SAVE_MS = 20000; // 20 seconds
  let autoSaveTimer = null;

  // tiny toast
  function toast(msg, ms=1500){
    ui.toast.textContent = msg; ui.toast.style.display='block';
    clearTimeout(ui._t); ui._t = setTimeout(()=> ui.toast.style.display='none', ms);
  }

  // Speech: speak text if allowed
  function speakText(text){
    if(!('speechSynthesis' in window)) return;
    try{
      const ut = new SpeechSynthesisUtterance(text);
      // choose a shorter voice if available
      const voices = window.speechSynthesis.getVoices();
      if(voices && voices.length) ut.voice = voices[0];
      window.speechSynthesis.cancel(); // cancel any previous to avoid overlap
      window.speechSynthesis.speak(ut);
    }catch(e){
      // ignore speech errors
      console.warn('TTS error', e);
    }
  }

  // Chart.js initialization (dataset.data uses {x:Date, y:number})
  const chart = new Chart(ui.chartCanvas.getContext('2d'), {
    type: 'line',
    data: { datasets: [
      { label: 'Angle (°)', data: [], borderColor:'#50c878', backgroundColor:'rgba(80,200,120,0.08)', pointRadius:0, tension:0.15 },
      { label: 'Mean', data: [], borderColor:'#ffc857', borderDash:[6,4], pointRadius:0, fill:false, tension:0 }
    ]},
    options: {
      animation: false,
      responsive: true,
      interaction: { mode: 'index', intersect: false },
      stacked: false,
      scales: {
        x: {
          type: 'time',
          time: { tooltipFormat: 'YYYY-MM-DD HH:mm:ss', unit: 'second', displayFormats: { second: 'HH:mm:ss' } },
          ticks: { autoSkip: true, maxTicksLimit: 6 }
        },
        y: { beginAtZero: false }
      },
      plugins: { legend: { display: true } }
    }
  });

  // helper: keep chartData as rolling buffer (e.g., last 10 minutes) to avoid memory growth
  function pushToChart(time, value){
    chartData.push({x: time, y: value});
    // keep max 10 minutes history to be safe (10*60 sec)
    const cutoff = new Date(Date.now() - 10*60*1000);
    while(chartData.length && chartData[0].x < cutoff) chartData.shift();
  }

  function updateKPIs(){
    ui.angle.textContent = Number.isFinite(currentAngle) ? currentAngle.toFixed(1) : '—';
    ui.min.textContent = isFinite(minVal) ? minVal.toFixed(1) : '—';
    ui.max.textContent = isFinite(maxVal) ? maxVal.toFixed(1) : '—';
    ui.zero.textContent = Number.isFinite(zero) ? zero.toFixed(1) : '—';
    const mean = sessionSamples.length ? sessionSamples.reduce((s,a)=>s+a.value,0)/sessionSamples.length : NaN;
    ui.mean.textContent = sessionSamples.length ? mean.toFixed(1) : '—';
    ui.jointRest.textContent = ui.joint.value.includes('Rest') ? 'Rest' : 'Active';
  }

  // update chart with rolling window
  function refreshChart(){
    const now = new Date();
    const windowStart = new Date(now.getTime() - LIVE_WINDOW_SEC*1000);
    const visible = chartData.filter(pt => pt.x >= windowStart);
    // dataset 0: raw visible, dataset 1: mean line
    const values = visible.map(pt => pt.y);
    const meanVal = values.length ? values.reduce((a,b)=>a+b,0)/values.length : NaN;
    chart.data.datasets[0].data = visible;
    chart.data.datasets[1].data = visible.map(pt => ({x: pt.x, y: meanVal}));
    chart.update('none');
  }

  // sensor handler
  function onDeviceOrientation(e){
    if(!running) return;
    // alpha/beta/gamma may be undefined on some browsers — guard
    const a = (typeof e.alpha === 'number') ? e.alpha : 0;
    const b = (typeof e.beta === 'number') ? e.beta : 0;
    const g = (typeof e.gamma === 'number') ? e.gamma : 0;
    // pick axis per selected plane
    let raw = 0;
    switch(ui.plane.value){
      case 'alpha': raw = ((a + 540) % 360) - 180; break; // yaw normalized
      case 'beta': raw = b; break; // pitch
      case 'gamma': raw = g; break; // roll
      default: raw = b;
    }
    const adjusted = raw - zero;
    // normalize to -180..180
    const wrapped = ((adjusted + 180) % 360) - 180;
    currentAngle = wrapped;
    // update min/max
    if(wrapped > maxVal) maxVal = wrapped;
    if(wrapped < minVal) minVal = wrapped;
    // push into session and chart buffers
    const now = new Date();
    sessionSamples.push({time: now, value: wrapped});
    pushToChart(now, wrapped);
    // update UI and chart
    updateKPIs();
    refreshChart();
  }

  // sensor start: handles iOS permission flow
  function enableSensors(){
    if(!('DeviceOrientationEvent' in window)){
      ui.sensorStatus.textContent = 'Sensors: not supported';
      toast('DeviceOrientation not supported');
      return;
    }
    // some iOS require requestPermission()
    if(typeof DeviceOrientationEvent.requestPermission === 'function'){
      DeviceOrientationEvent.requestPermission().then(permissionState => {
        if(permissionState === 'granted'){
          attachListener();
        } else {
          ui.sensorStatus.textContent = 'Sensors: blocked';
          toast('Permission denied for motion sensors');
        }
      }).catch(err => {
        console.warn('Permission error', err);
        ui.sensorStatus.textContent = 'Sensors: blocked';
        toast('Permission request failed');
      });
    } else {
      // non-iOS (Chrome/Android) usually do not require request
      attachListener();
    }
  }

  function attachListener(){
    if(listenerAdded) return;
    window.addEventListener('deviceorientation', onDeviceOrientation, {passive:true});
    listenerAdded = true;
    ui.sensorStatus.textContent = 'Sensors: ready';
    toast('Sensors enabled — press Start Session');
  }

  // auto-save routine (also speaks)
  function autoSaveAction(){
    if(!sessionSamples.length) return;
    // compute mean and last reading
    const mean = sessionSamples.reduce((s,a)=>s+a.value,0) / sessionSamples.length;
    const last = sessionSamples[sessionSamples.length - 1];
    // detailed timestamp with date
    const ts = new Date();
    const timestamp = ts.toLocaleString(); // includes date and time
    // create record and append to savedRecords + table
    const rec = {
      timestamp_iso: ts.toISOString(),
      timestamp_local: timestamp,
      joint: ui.joint.value,
      plane: ui.plane.value,
      side: ui.side.value,
      angle: Number(last.value.toFixed(2)),
      mean: Number(mean.toFixed(2))
    };
    savedRecords.push(rec);
    appendSavedRow(rec);
    // speak reading
    const speakStr = `${ui.joint.value} ${ui.side.value} — angle ${rec.angle} degrees. mean ${rec.mean} degrees.`;
    speakText(speakStr);
    toast('Auto-saved: ' + timestamp, 1500);
    // keep chartData (do not clear) so chart stays continuous
    // clear sessionSamples so next auto-window fresh (optional). We'll clear to keep mean per-interval meaningful
    sessionSamples.length = 0;
  }

  function appendSavedRow(rec){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${rec.timestamp_local}</td><td>${rec.joint}</td><td>${rec.plane}</td><td>${rec.side}</td><td>${rec.angle.toFixed(1)}</td><td>${rec.mean.toFixed(1)}</td>`;
    ui.savedBody.prepend(tr);
  }

  // Start/Stop controls
  ui.btnEnable.addEventListener('click', enableSensors);
  ui.btnStart.addEventListener('click', () => {
    if(!listenerAdded){
      toast('Enable sensors first');
      return;
    }
    if(running) return;
    running = true;
    ui.sensorStatus.textContent = 'Session: running';
    // start auto-save timer
    autoSaveTimer = setInterval(autoSaveAction, AUTO_SAVE_MS);
    toast('Session started');
  });
  ui.btnStop.addEventListener('click', () => {
    if(!running) return;
    running = false;
    ui.sensorStatus.textContent = 'Session: stopped';
    if(autoSaveTimer){ clearInterval(autoSaveTimer); autoSaveTimer = null; }
    // also do one final save of remaining samples
    autoSaveAction();
    toast('Session stopped and final auto-save completed', 1500);
  });

  ui.btnCalibrate.addEventListener('click', () => {
    zero = currentAngle || 0;
    toast('Zero set to ' + zero.toFixed(1));
    updateKPIs();
  });
  ui.btnResetMinMax.addEventListener('click', () => {
    minVal = Infinity; maxVal = -Infinity; updateKPIs(); toast('Min/Max reset');
  });

  // CSV export
  ui.btnExport.addEventListener('click', () => {
    if(!savedRecords.length){
      toast('No saved sessions to export');
      return;
    }
    // CSV header + rows with ISO timestamp and local timestamp
    const header = ['timestamp_iso','timestamp_local','joint','plane','side','angle_deg','mean_deg'];
    const rows = savedRecords.map(r => [
      r.timestamp_iso,
      `"${r.timestamp_local.replace(/"/g,'""')}"`,
      r.joint,
      r.plane,
      r.side,
      r.angle,
      r.mean
    ].join(','));
    const csv = [header.join(','), ...rows].join('\n');
    const blob = new Blob([`\uFEFF${csv}`], {type: 'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `youmove_sessions_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.csv`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    toast('Export ready');
  });

  // On page visibility change, stop speech if needed
  document.addEventListener('visibilitychange', () => {
    if(document.hidden && 'speechSynthesis' in window) window.speechSynthesis.cancel();
  });

  // Small demo: ensure voices loaded for TTS on some browsers
  window.speechSynthesis && window.speechSynthesis.getVoices();

  // expose for debug (optional)
  window.YOUMOVE = { chartData, sessionSamples, savedRecords };

})();
</script>
</body>
</html>
